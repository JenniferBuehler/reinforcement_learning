.TH "rl::MaxUtilityActionAlgorithm< State, Action >" 3 "Wed Oct 28 2015" "LearningAlgorithms" \" -*- nroff -*-
.ad l
.nh
.SH NAME
rl::MaxUtilityActionAlgorithm< State, Action > \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <MaxUtility\&.h>\fP
.PP
Inherits \fBrl::ActionAlgorithm< Action >\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef Action \fBActionT\fP"
.br
.ti -1c
.RI "typedef State \fBStateT\fP"
.br
.ti -1c
.RI "typedef float \fBFloatT\fP"
.br
.ti -1c
.RI "typedef \fBUtility\fP< \fBStateT\fP, \fBFloatT\fP > \fBUtilityT\fP"
.br
.ti -1c
.RI "typedef \fBTransition\fP< \fBStateT\fP, \fBActionT\fP > \fBTransitionT\fP"
.br
.ti -1c
.RI "typedef \fBTransitionT::StateTransitionListT\fP \fBStateTransitionListT\fP"
.br
.ti -1c
.RI "typedef \fBTransitionT::StateTransitionListPtrT\fP \fBStateTransitionListPtrT\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBMaxUtilityActionAlgorithm\fP (const \fBUtilityT\fP &_u, const \fBTransitionT\fP &_t, const \fBStateT\fP &_s)"
.br
.ti -1c
.RI "virtual bool \fBapply\fP (const \fBActionT\fP &a)"
.br
.ti -1c
.RI "\fBFloatT\fP \fBgetValue\fP ()"
.br
.ti -1c
.RI "\fBActionT\fP \fBgetBestAction\fP ()"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<class State, class Action>class rl::MaxUtilityActionAlgorithm< State, Action >"
For all actions which can be performed, finds the action with maximum utility, considering the probability for the action\&. Formally, it calculates: max_over_a{sum_over_all_s'[T(s,a,s')*U(s')]} where T is the transition function, and U the utility function 
.PP
\fBAuthor:\fP
.RS 4
Jennifer Buehler 
.RE
.PP
\fBDate:\fP
.RS 4
May 2011 
.RE
.PP

.SH "Member Typedef Documentation"
.PP 
.SS "template<class State , class Action > typedef Action \fBrl::MaxUtilityActionAlgorithm\fP< State, Action >::\fBActionT\fP"

.SS "template<class State , class Action > typedef float \fBrl::MaxUtilityActionAlgorithm\fP< State, Action >::\fBFloatT\fP"

.SS "template<class State , class Action > typedef State \fBrl::MaxUtilityActionAlgorithm\fP< State, Action >::\fBStateT\fP"

.SS "template<class State , class Action > typedef \fBTransitionT::StateTransitionListPtrT\fP \fBrl::MaxUtilityActionAlgorithm\fP< State, Action >::\fBStateTransitionListPtrT\fP"

.SS "template<class State , class Action > typedef \fBTransitionT::StateTransitionListT\fP \fBrl::MaxUtilityActionAlgorithm\fP< State, Action >::\fBStateTransitionListT\fP"

.SS "template<class State , class Action > typedef \fBTransition\fP<\fBStateT\fP,\fBActionT\fP> \fBrl::MaxUtilityActionAlgorithm\fP< State, Action >::\fBTransitionT\fP"

.SS "template<class State , class Action > typedef \fBUtility\fP<\fBStateT\fP,\fBFloatT\fP> \fBrl::MaxUtilityActionAlgorithm\fP< State, Action >::\fBUtilityT\fP"

.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<class State , class Action > \fBrl::MaxUtilityActionAlgorithm\fP< State, Action >::\fBMaxUtilityActionAlgorithm\fP (const \fBUtilityT\fP & _u, const \fBTransitionT\fP & _t, const \fBStateT\fP & _s)\fC [inline]\fP"

.SH "Member Function Documentation"
.PP 
.SS "template<class State , class Action > virtual bool \fBrl::MaxUtilityActionAlgorithm\fP< State, Action >::apply (const \fBActionT\fP & a)\fC [inline]\fP, \fC [virtual]\fP"

.PP
Implements \fBrl::ActionAlgorithm< Action >\fP\&.
.SS "template<class State , class Action > \fBActionT\fP \fBrl::MaxUtilityActionAlgorithm\fP< State, Action >::getBestAction ()\fC [inline]\fP"

.SS "template<class State , class Action > \fBFloatT\fP \fBrl::MaxUtilityActionAlgorithm\fP< State, Action >::getValue ()\fC [inline]\fP"


.SH "Author"
.PP 
Generated automatically by Doxygen for LearningAlgorithms from the source code\&.
