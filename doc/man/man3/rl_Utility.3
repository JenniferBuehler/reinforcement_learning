.TH "rl::Utility< State, Value >" 3 "Wed Oct 28 2015" "LearningAlgorithms" \" -*- nroff -*-
.ad l
.nh
.SH NAME
rl::Utility< State, Value > \- Implements the utility function which expresses the utility of a state\&. This can be a function or a lookup in a table\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Utility\&.h>\fP
.PP
Inherited by \fBrl::MappedUtility< State, Value >\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef State \fBStateT\fP"
.br
.ti -1c
.RI "typedef Value \fBValueT\fP"
.br
.ti -1c
.RI "typedef \fBUtility\fP< \fBStateT\fP, \fBValueT\fP > \fBUtilityT\fP"
.br
.ti -1c
.RI "typedef std::shared_ptr< \fBUtilityT\fP > \fBUtilityPtrT\fP"
.br
.ti -1c
.RI "typedef std::shared_ptr< const \fBUtilityT\fP > \fBUtilityConstPtrT\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBUtility\fP ()"
.br
.ti -1c
.RI "\fBUtility\fP (const \fBUtility\fP &o)"
.br
.ti -1c
.RI "virtual \fB~Utility\fP ()"
.br
.ti -1c
.RI "virtual \fBValueT\fP \fBgetUtility\fP (const \fBStateT\fP &s, float &mean, float &variance) const =0"
.br
.ti -1c
.RI "virtual void \fBexperienceUtility\fP (const \fBStateT\fP &s, const \fBValueT\fP &v)=0"
.br
.ti -1c
.RI "virtual bool \fBsupportsMeanVariance\fP (bool &onlyMean)"
.br
.ti -1c
.RI "virtual \fBUtilityPtrT\fP \fBclone\fP () const =0"
.br
.ti -1c
.RI "virtual void \fBprint\fP (std::stringstream &str) const =0"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBUtilityPtrT\fP \fBmakePtr\fP (\fBUtilityT\fP *ref)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<class State, typename Value = float>class rl::Utility< State, Value >"
Implements the utility function which expresses the utility of a state\&. This can be a function or a lookup in a table\&. 

This interface can also be used for learning a utility function, by using method \fBexperienceUtility()\fP\&.
.PP
\fBParameters:\fP
.RS 4
\fIState\fP template class for State description\&. Prerequisite: Must support < operator, an be uniquely identifiable, i\&.e\&. suitable to use in a std::map as key\&. Even if the \fBUtility\fP is being calculated as a function by the underlying implementation, it is to be made sure that a map-lookup can be used as well for each state\&.
.br
\fIValue\fP the value type to be used as utility 
.RE
.PP
\fBAuthor:\fP
.RS 4
Jennifer Buehler 
.RE
.PP
\fBDate:\fP
.RS 4
May 2011 
.RE
.PP

.SH "Member Typedef Documentation"
.PP 
.SS "template<class State , typename Value  = float> typedef State \fBrl::Utility\fP< State, Value >::\fBStateT\fP"

.SS "template<class State , typename Value  = float> typedef std::shared_ptr<const \fBUtilityT\fP> \fBrl::Utility\fP< State, Value >::\fBUtilityConstPtrT\fP"

.SS "template<class State , typename Value  = float> typedef std::shared_ptr<\fBUtilityT\fP> \fBrl::Utility\fP< State, Value >::\fBUtilityPtrT\fP"

.SS "template<class State , typename Value  = float> typedef \fBUtility\fP<\fBStateT\fP,\fBValueT\fP> \fBrl::Utility\fP< State, Value >::\fBUtilityT\fP"

.SS "template<class State , typename Value  = float> typedef Value \fBrl::Utility\fP< State, Value >::\fBValueT\fP"

.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<class State , typename Value  = float> \fBrl::Utility\fP< State, Value >::\fBUtility\fP ()\fC [inline]\fP"

.SS "template<class State , typename Value  = float> \fBrl::Utility\fP< State, Value >::\fBUtility\fP (const \fBUtility\fP< State, Value > & o)\fC [inline]\fP"

.SS "template<class State , typename Value  = float> virtual \fBrl::Utility\fP< State, Value >::~\fBUtility\fP ()\fC [inline]\fP, \fC [virtual]\fP"

.SH "Member Function Documentation"
.PP 
.SS "template<class State , typename Value  = float> virtual \fBUtilityPtrT\fP \fBrl::Utility\fP< State, Value >::clone () const\fC [pure virtual]\fP"

.PP
Implemented in \fBrl::MappedUtility< State, Value >\fP\&.
.SS "template<class State , typename Value  = float> virtual void \fBrl::Utility\fP< State, Value >::experienceUtility (const \fBStateT\fP & s, const \fBValueT\fP & v)\fC [pure virtual]\fP"
A specific utility was experienced in this state\&. It depends on the implementing subclass whether this will trigger any internal changes (e\&.g\&. learning), though in most implementations this should have an effect\&. 
.PP
Implemented in \fBrl::MappedUtility< State, Value >\fP\&.
.SS "template<class State , typename Value  = float> virtual \fBValueT\fP \fBrl::Utility\fP< State, Value >::getUtility (const \fBStateT\fP & s, float & mean, float & variance) const\fC [pure virtual]\fP"
Returns utility for the state, alogn with a mean and variance expressing the confidence of this utility\&. Some subclasses may not support mean and variance\&. Find out with method \fBsupportsMeanVariance()\fP; If not supported, the values of parameters mean and variance will be undefined\&. 
.PP
Implemented in \fBrl::MappedUtility< State, Value >\fP\&.
.SS "template<class State , typename Value  = float> static \fBUtilityPtrT\fP \fBrl::Utility\fP< State, Value >::makePtr (\fBUtilityT\fP * ref)\fC [inline]\fP, \fC [static]\fP"

.SS "template<class State , typename Value  = float> virtual void \fBrl::Utility\fP< State, Value >::print (std::stringstream & str) const\fC [pure virtual]\fP"

.PP
Implemented in \fBrl::MappedUtility< State, Value >\fP\&.
.SS "template<class State , typename Value  = float> virtual bool \fBrl::Utility\fP< State, Value >::supportsMeanVariance (bool & onlyMean)\fC [inline]\fP, \fC [virtual]\fP"
Should return true for subclasses which return mean (and variance) in function \fBgetUtility()\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIonlyMean\fP will be set to true if the function supports only the mean, and no variance\&. If the function returns false, the value of this parameter is undefined\&. 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for LearningAlgorithms from the source code\&.
