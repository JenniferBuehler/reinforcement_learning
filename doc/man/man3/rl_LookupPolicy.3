.TH "rl::LookupPolicy< State, Action >" 3 "Wed Oct 28 2015" "LearningAlgorithms" \" -*- nroff -*-
.ad l
.nh
.SH NAME
rl::LookupPolicy< State, Action > \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Policy\&.h>\fP
.PP
Inherits \fBrl::Policy< State, Action >\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef State \fBStateT\fP"
.br
.ti -1c
.RI "typedef Action \fBActionT\fP"
.br
.ti -1c
.RI "typedef \fBPolicy\fP< \fBStateT\fP, \fBActionT\fP > \fBPolicyT\fP"
.br
.ti -1c
.RI "typedef \fBPolicyT::PolicyPtrT\fP \fBPolicyPtrT\fP"
.br
.ti -1c
.RI "typedef \fBLookupPolicy\fP< \fBStateT\fP, \fBActionT\fP > \fBLookupPolicyT\fP"
.br
.ti -1c
.RI "typedef std::shared_ptr< \fBLookupPolicyT\fP > \fBLookupPolicyPtrT\fP"
.br
.ti -1c
.RI "typedef std::shared_ptr< const \fBLookupPolicyT\fP > \fBLookupPolicyConstPtrT\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBLookupPolicy\fP ()"
.br
.ti -1c
.RI "\fBLookupPolicy\fP (const \fBLookupPolicy\fP &o)"
.br
.ti -1c
.RI "virtual \fB~LookupPolicy\fP ()"
.br
.ti -1c
.RI "virtual bool \fBgetAction\fP (const State &s, Action &targetAction) const "
.br
.ti -1c
.RI "virtual void \fBbestAction\fP (const State &s, const Action &a, float utility=1\&.0, float confidence=1\&.0)"
.br
.ti -1c
.RI "virtual \fBPolicyPtrT\fP \fBclone\fP () const "
.br
.ti -1c
.RI "virtual void \fBprint\fP (std::ostream &o) const "
.br
.in -1c
.SS "Protected Types"

.in +1c
.ti -1c
.RI "typedef std::map< State, Action > \fBPolicyMapT\fP"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBPolicyMapT\fP \fBp\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<class State, class Action>class rl::LookupPolicy< State, Action >"
Simple table lookup policy\&. \fBbestAction()\fP replaces an action for a state\&. 
.PP
\fBAuthor:\fP
.RS 4
Jennifer Buehler 
.RE
.PP
\fBDate:\fP
.RS 4
May 2011 
.RE
.PP

.SH "Member Typedef Documentation"
.PP 
.SS "template<class State , class Action > typedef Action \fBrl::LookupPolicy\fP< State, Action >::\fBActionT\fP"

.SS "template<class State , class Action > typedef std::shared_ptr<const \fBLookupPolicyT\fP> \fBrl::LookupPolicy\fP< State, Action >::\fBLookupPolicyConstPtrT\fP"

.SS "template<class State , class Action > typedef std::shared_ptr<\fBLookupPolicyT\fP> \fBrl::LookupPolicy\fP< State, Action >::\fBLookupPolicyPtrT\fP"

.SS "template<class State , class Action > typedef \fBLookupPolicy\fP<\fBStateT\fP,\fBActionT\fP> \fBrl::LookupPolicy\fP< State, Action >::\fBLookupPolicyT\fP"

.SS "template<class State , class Action > typedef std::map<State,Action> \fBrl::LookupPolicy\fP< State, Action >::\fBPolicyMapT\fP\fC [protected]\fP"

.SS "template<class State , class Action > typedef \fBPolicyT::PolicyPtrT\fP \fBrl::LookupPolicy\fP< State, Action >::\fBPolicyPtrT\fP"

.SS "template<class State , class Action > typedef \fBPolicy\fP<\fBStateT\fP,\fBActionT\fP> \fBrl::LookupPolicy\fP< State, Action >::\fBPolicyT\fP"

.SS "template<class State , class Action > typedef State \fBrl::LookupPolicy\fP< State, Action >::\fBStateT\fP"

.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<class State , class Action > \fBrl::LookupPolicy\fP< State, Action >::\fBLookupPolicy\fP ()\fC [inline]\fP"

.SS "template<class State , class Action > \fBrl::LookupPolicy\fP< State, Action >::\fBLookupPolicy\fP (const \fBLookupPolicy\fP< State, Action > & o)\fC [inline]\fP"

.SS "template<class State , class Action > virtual \fBrl::LookupPolicy\fP< State, Action >::~\fBLookupPolicy\fP ()\fC [inline]\fP, \fC [virtual]\fP"

.SH "Member Function Documentation"
.PP 
.SS "template<class State , class Action > virtual void \fBrl::LookupPolicy\fP< State, Action >::bestAction (const State & s, const Action & a, float utility = \fC1\&.0\fP, float confidence = \fC1\&.0\fP)\fC [inline]\fP, \fC [virtual]\fP"
Under certain circumstances, the Action a was determined best for the State s\&. This should lead to an update of the policy, either by inserting/replacing this action in a table, or by feeding a learning algorithm\&. If available, a utility estimate for this state-action pair can be passed for use by learning algorithms, along with a confidence value [0\&.\&.1] that this action will successfully lead to this utility\&. This could be used to trade off the choice of an action using a risk factor, when returning an action in getAction(State&)\&. In a simple state-action lookup implementation, the parameters confidence and utility won't have any effect\&. 
.PP
Implements \fBrl::Policy< State, Action >\fP\&.
.SS "template<class State , class Action > virtual \fBPolicyPtrT\fP \fBrl::LookupPolicy\fP< State, Action >::clone () const\fC [inline]\fP, \fC [virtual]\fP"

.PP
Implements \fBrl::Policy< State, Action >\fP\&.
.SS "template<class State , class Action > virtual bool \fBrl::LookupPolicy\fP< State, Action >::getAction (const State & s, Action & targetAction) const\fC [inline]\fP, \fC [virtual]\fP"
Get the action to perform in a certain state\&. If non action assigned to this state, returns false\&. Otherwise, will contain the action to be performed in targetAction\&. 
.PP
Implements \fBrl::Policy< State, Action >\fP\&.
.SS "template<class State , class Action > virtual void \fBrl::LookupPolicy\fP< State, Action >::print (std::ostream & o) const\fC [inline]\fP, \fC [virtual]\fP"

.PP
Implements \fBrl::Policy< State, Action >\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "template<class State , class Action > \fBPolicyMapT\fP \fBrl::LookupPolicy\fP< State, Action >::p\fC [protected]\fP"


.SH "Author"
.PP 
Generated automatically by Doxygen for LearningAlgorithms from the source code\&.
